States/state machines

Individual enemy types need their own source/header files.
Call the function to create a specific enemy
When an enemy is created, the enemy source file should assign it a state machine
Then it should create a blank state machine

Then, it should create each of the states manually. It should populate them with stateData if relevant, and gives the function pointers for the thinkg/update funcitons

States have a name. When switching states, it iterates through each state and finds the state with the same name then switches to it. Also, changing state sets the entity's update/think functions to those of the state

State machine:
- A pointer array of states
- current state pointer

States:
- Enter function
- Exit function
- Process
- Think
- Name

moveState(State * currentState, State * nextState) function:
- Plays exit function on current state
- Plays enter function on next state

---------

How to do entity animations:
"Play animation" function
Sets animationTimeTracker to 0
Sets animationFrameTracker to 0
whenever animationFrameTracker passes (1 / 60), advance frame by 1
When animationTimeTrakcer passes (fram6eCount / 60), run "animationFinished"

Animation setup:
animationSetup() function that takes a folder and stores that folder as a const char*

Play animation:
animationPlay() takes an animation name, appends it to the folder, and then appends ".model" to it
It loads the model and also gets the count of frames from the obj_list which gets frameCount of the animation. If it returns 0 and it is a regular obj then no animation
 

House:
Figure out how to make the door push the character (Check if detected, and if so, use the actor's velocity as 1 pointed towards the object if velocity is 0?)
uv map that thing
Has positions for ammo/health pickup
Has position for powerup
Has position for door

Door:
Have the door check if it is colliding with any character3d. If so, push the character3d half the distance away

One functioning enemy

Idea:
When enemy is spawned, gets given a point on the map where it walks around a certain radius. When the player is a certain distance from it,
the enemy will approach the player. If the player is too far, the enemy will make their current point the new epicenter for wandering around.




	Pickups



DONE:
Transfer some stuff from the player to Character3D

add screenshake on using gun:
- Hehe camera trauma implemented

One functioning gun UI
- UI object has a "drawUI" function
- "drawUI" checks if the player data is valid, and if so, runs the "drawPlayerUI" function
- "drawPlayerUI" draws the sprites associated with the current weapon as well as remaining ammo in the bottom left (shoot for basic grey circle, text, and 1 png of pistol)

DELIVERABLES:

UI Elements reflecting in game information
Functioning Entity System
Basic Collision Detection
Basic User Controls
A contained game world


10 weapons
5 enemy types
2 stages with a shop between them
5 powerups
	Infinite ammo
	No jerk
	Half cooldown
	Invincible
	Double speed
5 map interactable elements
    Interact button
    Doors that can be opened
    Ammo that can be found in abandoned houses?
    A melee QTE attack on enemies after a headshot
    The shop
